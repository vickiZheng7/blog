# ES6标准全整理

## let、const命令和块级作用域

### let命令

let命令声明的变量只在其所在的代码块中有效。

#### 不存在变量提升

变量提升的概念存在于var命令，指的是变量在声明之前可使用，并且值为undefined，这并不符合一般编程逻辑，即先声明后使用。

在ES5中，为了减少运行错误，强调养成良好的编程习惯，不使用未声明的变量，避免出现意料之外的行为，但不使用不代表不可用，这并没有从根源上解决问题。

在ES6中，let命令纠正了这一对象，如果使用未声明的变量，编译将会报错。

#### 暂时性死区

先看下面这个例子：

```javascript
var x = "hello world"
if (true) {
    console.log(x)//reference error
    let x = "goodbye helloworld"
}
```

在if代码块中，let命令声明了一个x变量，在声明之前使用x变量时，报错。从代码块开始到let声明变量x之前，这个区域是变量x的暂时性死区，即使这个变量在外部已经声明。

##### 注意

暂时性死区导致typeof不再是100%安全的操作。反而，如果一个变量没有被声明，使用typeof不会报错。
因此良好的编程习惯一定要保持：变量一定要在声明之后使用。

#### 不允许重复声明

在相同作用域内不能使用let重复声明变量。

#### 特殊的for循环

```javascript
for (let i = 0; i <= 10; i++) {
    let i = "123"
    console.log(i)
}
```

结果输出10个"123"字符串。

在这个for循环中，循环变量是父作用域，循环内部是子作用域，两个i不在同一个作用域内，因此互不影响。

#### 全局变量与顶层对象无关

在JavaScript中，顶层对象的属性等价于全局变量，var声明的全局变量也能通过顶层属性访问得到，而且顶层对象根据环境的不同而异，比如浏览器中的window对象。这带来了几个困扰：

* 无法在编译时提示变量未声明的错误，因为这个变量可能为顶层对象的属性。
* 可能在不知不觉中添加了全局变量。
* 顶层对象的属性到处可读写，不利于模式化编程。
* 顶层对象不应该包含有实体含义，比如window对象包含了窗口的实体含义。

在ES6中，let声明的全局变量不属于顶层对象的属性(包括const、class)，由此与顶层对象隔离开。但是var和function命令声明的变量仍然属于顶层对象的属性，以保持兼容性。

###const命令

const命令与let命令相似，区别是变量为只读模式，一旦声明之后值不可以改变。

const只读的本质不是变量值不得改动，而是指向的内存地址不得改动。

* 简单数据类型：值就保存在指向的内存地址中。

* 复合数据类型：内存地址保存的是指针，至于指针指向的数据结构，const不做任何保证，因此操作时必须小心。

如果希望对象下属性的值也只读，可以使用`object.freeze`方法冻结对象。

```javascript
const obj = Object.freeze({foo: "123"})
obj.foo = "abc"
obj.foo//"123"
```

常规模式下，对属性赋值不起任何作用；严格模式下，对属性赋值会报错。

想要彻底冻结，如果对象的属性值的数据类型也是对象，那么也需要冻结该属性的值。

### 块级作用域

在ES5中，只有全局作用域和函数作用域，并没有块级作用域，导致很多场景不合理。比如：

* 内层变量覆盖外层变量
* 计数循环变量泄漏成为全局变量

没有块级作用域的情况下，我们常使用了IIFE写法模拟块级作用域，来避免变量污染。

```javascript
(function() {
    //...
}());
```

在ES6中，有了let和const命令，声明的变量只在其代码块中有效，这里就有了块级作用域。

## 解构赋值

**解构**指的是通过**模式匹配**从数组或对象中提取值。当等号两边的模式相同，左边的变量会被赋予右边对应的值。

**不完全解构**：等号左边的模式只匹配一部分等号右边的模式。

### 不同数据类型的解构赋值

#### 数组

按照顺序匹配值。

```javascript
let [a, b, c] = [1, 2, 3]
let [a, [b1, b2], c] = [1, [2.1, 2.2], 3]
```

只要某种数据结构具有Iterator接口，都可以采用数组形式进行解构赋值。

#### 对象

按照属性名匹配值。

```javascript
let {foo} = {foo: "123"}
```

匹配对象中的foo属性，并且将属性值赋值给变量foo。因此，上面解构的最终变量名与属性名一致。

如果希望最终变量名不与属性名一致，须写成：

```javascript
let {foo: baz} = {foo: "123"}
```

其中foo指的是匹配模式，baz指的是变量名，解构赋值的内部机制是先找到同名属性，再赋值给变量。所以：

```javascript
let {foo} = {foo: "123"}
//等同于以下表达式的简写
let {foo: foo} = {foo: "123"}
```

也可用于嵌套模式

```javascript
let {p: {x: baz}} = {p: {x: 1, y: 2}}
baz//1
```

实际上，数组是特殊的对象，因此数组也可以使用对象形式进行解构赋值，匹配的属性名即数组索引。

```javascript
let {0: first, 1: second, length: len} = [1, 2, 3]
first//1
length//3
```

#### 其他数据类型

如果等号右边是其他数据类型，那么在进行解构之前，会先将值转换为对象。但undefined和null无法转换成对象，所以当右边值为undefined或null时，解构赋值会报错。

##### 字符串

转换成一个类似数组的对象。

```javascript
let {length: len} = "helloworld";
len//10
```

##### 数值

```javascript
let {toString: s} = 12;
s === Number.prototype.toString//true
```

等等。

#### 注意

以上都是声明赋值，已声明的变量也可用于解构赋值。

```javascript
let x
[x] = [1]
x//1
({foo: x} = {foo: "123"})
x//"123"
```

这里要注意，没有声明命令的对象形式的解构赋值，行首是以大括号开始的。JS引擎会将行首为大括号的`{x}`理解成代码块，从而引发语法错误。所以使用圆括号包起来，不让大括号成为行首。

### 允许指定默认值

```javascript
let [x = 1] = [];
x//1
let {y: z = 1} = {}
z//1
```

ES6内部使用严格相等运算符(===)判断一个位置是否有值，如果值===undefined，那么使用默认值。

```javascript
let [x = 1] = [undefined]
x//1
let [y = 1] = [null]
y//null
```

如果默认值是一个表达式，那么这个表达式是惰性求值，即只有用到才求值。

```javascript
let counter = 0;
function getVal() {
    return counter++;
}
let [x = getVal()] = [1];
counter//0
```

上面的例子中，x匹配得到值，因此getVal()没有执行，counter值未变。

### 用途

#### 变量值交换

```javascript
let x = 1, y = 2
[x, y] = [y, x]
x//2
y//1
```

#### 从函数返回多个值

```javascript
function getVal() {
    return [1, 2]
}
let [a, b] = getVal();
```

#### 函数参数的定义

数组有序传入多个参数

```javascript
function setVal([a, b, c]) {}
setVal([1, 2, 3])
```

对象无序传入多个参数。当函数参数多时，将参数集合到对象中传入函数，由函数解构获值，可免去按照顺序传入多参数的烦恼。

```javascript
function setVal({a, b, c}) {}
setVal({b: 2, a: 1, c: 3})
```

#### 提取JSON数据

#### 函数参数指定默认值



