# 生命周期

每个Vue实例在被创建时都要经过一系列的初始化过程，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同阶段添加自己的代码的机会。 

## Vue定义入口

想知道不同Vue版本的入口文件，可在`vue/blob/dev/scripts/config.js`文件中查看entry信息。

```javascript
// Runtime+compiler ES modules build (for bundlers)
'web-full-esm': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.js'),
    format: 'es',
    alias: { he: './entity-decoder' },
    banner
},
```

以runtime+compiler(包含编译器和运行时)的Vue版本为例，得到`import Vue from "vue"`的入口：`vue/src/platforms/web/entry-runtime-with-compiler.js`。

```javascript
//vue/src/platforms/web/entry-runtime-with-compiler.js
//...
import Vue from './runtime/index';
//...
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  //...
  return mount.call(this, el, hydrating)
}
//...
export default Vue
```

文件中并没有Vue的定义，Vue是从`./runtime/index`运行时文件中导出的，还要继续挖掘。在那之前，先明确这个文件的作用。

`entry-runtime-with-compiler.js`对Vue的实例方法`$mount`进行了拓展，使其能够检查到template属性的存在并进行编译，将template属性转换成render函数（Vue直接通过`render`函数生成最终模板，而不是template），因此当前的Vue版本能够同时支持runtime和compiler。

对比`entry-runtime.js`，`entry-runtime-with-compiler.js`文件的主要目的是让Vue支持compiler编译。

```javascript
//vue/src/platforms/web/runtime/index.js
import Vue from 'core/index'
import { mountComponent } from 'core/instance/lifecycle'
//...
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
//...
```

`./runtime/index.js`文件中仍然没有定义Vue，Vue从`core/index`导出。当前文件主要根据不同平台进行预处理，支持开发环境使用devtools调试工具。同时，定义了实例方法`$mount`，支持手动挂载为挂载的实例。

```javascript
//vue/src/core/instance/index.js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

到达目的地。

创建Vue实例，是从Vue函数开始的。显而易见，其实就是开始_init初始化过程。

这个文件中我们并没有找到`_init`方法的定义，但可以看到有很多以`mixin`为后缀的方法，如`initMixin`、`stateMixin`等等。这些方法给Vue的`prototype`拓展功能用的，`_init`方法便是在`initMixin`内定义的。为了方便管理维护，Vue把功能分别扩散到各个模块中。

## 钩子函数调用方法

为了让阅读更加流畅，在探索生命周期之前，先熟悉在各个阶段如何调用钩子函数。

在不同的生命节点，Vue通过callHook方法来调用**钩子函数**。

```javascript
//vue/src/core/instance/lifecycle.js
export function callHook (vm: Component, hook: string) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const handlers = vm.$options[hook]
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      //src/core/util/error.js, call调用，包括错误捕获处理
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

callHook方法很好理解，根据hook（钩子名称）获取options对应的handlers数组（options在初始化过程中被解析，钩子函数被处理成数组形式），遍历执行钩子函数。

## 初始化实例

在`initMixin`方法内找到初始化的实例方法`_init`。在生命周期中，实例的创建和挂载都是在初始化过程完成的。

```javascript
//vue/src/core/instance/init.js
export function initMixin (Vue: Class<Component>) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    //...
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')
    //...
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
```



## create

在`beforeCreate`之前，会对生命周期、事件、渲染相关的参数进行初始化。比如`initLifecycle`

在`beforeCreate`和`created`之间，

```javascript
//vue/src/core/instance/state.js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

`initState`方法对props、methods、data、computed、watch等属性进行初始化，因此在`beforeCreate`钩子函数中是无法获取到data、props、computed的属性值的，也无法调用methods定义的方法。截至`created`之前，Vue并没有渲染DOM，这个阶段之前DOM均无法访问得到。一般来说，若当前实例需要从后端加载初始状态数据时，在`beforeCreated`或`created`阶段均可与后端交互。若需要获取props、data等值或调用methods的方法，只能在`created`之后的钩子内进行。

## mount

`created`后，开始挂载DOM：`vm.$mount(vm.$options.el)`。

在查找Vue定义入口过程中，Vue拓展了$mount的实例方法，并且在初始化过程中调用来挂载DOM。

```javascript
//vue/src/platforms/web/entry-runtime-with-compiler.js
//...
import Vue from './runtime/index';
//...
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  //..  
  //如果有template属性，解析成render函数
  if (template) { 
  	//... 
  	const { render, staticRenderFns } = compileToFunctions(template, {
      shouldDecodeNewlines,
      shouldDecodeNewlinesForHref,
      delimiters: options.delimiters,
      comments: options.comments
    }, this)
    options.render = render
  	//...
  }
  return mount.call(this, el, hydrating)
}
//...
export default Vue
```

没有render时，若存在template模板，将模板编译成render函数（若不存在template，el的outerHTML作为template）。

```javascript
//vue/src/platforms/web/runtime/index.js
import Vue from 'core/index'
import { mountComponent } from 'core/instance/lifecycle'
//...
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
//...
```

`$mount`中挂载DOM的关键操作由`mountComponent(this, el, hydrating)`执行。

```javascript
//vue/src/core/instance/lifecycle.js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    //..  
  }
  callHook(vm, 'beforeMount')
  //...
  let updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

为了方便理解，仅提取了源码的关键部分，详细的源码在github上查看。

在DOM挂载之前，`callHook(vm, 'beforeMount')`调用`beforeMount`钩子。

接着，Vue通过`vm._render()`执行render函数生成vnode，然后执行`vm._update()`将vnode patch到真正的DOM元素上，最后执行`mounted`钩子。到这里，DOM就挂载完成啦。

## update

在`mountComponent`内Vue实例化了一个`watcher`。

```javascript
new Watcher(vm, updateComponent, noop, {
  before () {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate')
    }
  }
}, true)
  }, true /* isRenderWatcher */)
```

在`mount`过程中它用于渲染组件，在`update`过程中它用于监听数据变化然后重绘组件。在重新渲染之前，会执行`beforeUpdate`钩子函数。那么`updated`钩子是在什么时候执行的呢？

我们将关注点聚焦在`watcher`，显然`beforeUpdate`是`watcher`在监听到数据变化并且重绘组件之前执行的。

```javascript
//vue/src/core/observer/watcher.js
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) {
    this.run()
  } else {
    queueWatcher(this)
  }
}
```

监听到数据变化之后，`watcher`会调用`update`来更新视图。`queueWatcher`将监听器推入`scheduler`的待刷新队列中等待调度。

```javascript
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort((a, b) => a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
    // in dev build, check and stop circular updates.
    //...

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}

function callUpdatedHooks (queue) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated')
    }
  }
}
```

`update`钩子是在视图更新结束之后调用的，也就是`flushSchedulerQueue`刷新队列调度结束之后。

##  destory

`beforeDestroy`和`destroy`两个钩子显然是在销毁组件前后调用的，销毁组件的实例方法是`$destroy`，是在定义Vue的时候拓展到Vue实例上的。

```javascript
//vue/src/core/instance/index.js
//...
import { lifecycleMixin } from './lifecycle'

function Vue (options) {
  //...
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

`lifecycleMixin`的作用是给Vue拓展数个与生命周期相关的实例方法，包括`_update`、`$forceUpdate`和`$destroy`。

```javascript
Vue.prototype.$destroy = function () {
	const vm: Component = this
   	if (vm._isBeingDestroyed) {
		return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
		remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
		vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
		vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
		vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
		vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
		vm.$vnode.parent = null
    }
}
```

在销毁组件之前，执行开发者规定的“销毁前”动作——`callhook(vm, 'beforeDestroy')`，常用于移除绑定到window的`eventListener`等操作。接着开始正式销毁：从`parent`的`parent.$children`卸载自身，移除`watcher`，确认销毁并且销毁当前的渲染树，然后调用`destory`钩子函数。到这里还没结束，还要将实例的`eventListener`全部移除——`vm.$off`。至此整个销毁才算完成了。



